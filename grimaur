#!/usr/bin/env python3
"""grimaur: Fetch, inspect, search, update, and install Arch Linux AUR packages.

By default this tool queries the official AUR RPC API and automatically falls back to
the git mirror at https://github.com/archlinux/aur.git when the endpoint is
unavailable. Each package lives on its own branch in the mirror, and grimaur can
recursively resolve and install dependencies by building packages locally with
makepkg. Official repository dependencies are installed with pacman when they are
missing.

Requirements: git, makepkg, pacman, and (for installing official packages) sudo/root.
"""
from __future__ import annotations

import argparse
import json
import os
import re
import shutil
import subprocess
import sys
import urllib.error
import urllib.parse
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Set

AUR_REMOTE = "https://github.com/archlinux/aur.git"
OFFICIAL_AUR_GIT_BASE = "https://aur.archlinux.org"
CGIT_RAW_BASE = "https://aur.archlinux.org/cgit/aur.git/plain"
AUR_RPC_ENDPOINT = "https://aur.archlinux.org/rpc/"
GITHUB_RAW_BASE = "https://raw.githubusercontent.com/archlinux/aur"
_VCS_SUFFIXES = ("-git", "-vcs", "-svn", "-hg", "-bzr", "-darcs", "-cvs")

RESET = "\033[0m"
BOLD = "\033[1m"
GREEN = "\033[32m"
CYAN = "\033[36m"
YELLOW = "\033[33m"
DIM = "\033[2m"

USE_COLOR = False
USE_AUR_RPC = False
FORCE_GIT_MIRROR = False
_INSTALLED_CACHE: Optional[Set[str]] = None
_PROVIDES_CACHE: dict[str, Optional[Set[str]]] = {}
_VIRTUAL_PROVIDER_CACHE: dict[str, Optional[str]] = {}
_AUR_INFO_CACHE: dict[str, Optional[dict]] = {}
_RPC_FALLBACK_NOTIFIED = False

_COMMON_AUR_SUFFIXES = ("-bin",)

_GLOBAL_FLAG_OPTIONS = {"--refresh", "--no-color", "--aur-rpc", "--git-mirror"}
_GLOBAL_VALUE_OPTIONS = {"--dest-root"}


def style(text: str, *codes: str) -> str:
    if not USE_COLOR or not codes:
        return text
    return "".join(codes) + text + RESET


def disable_aur_rpc(reason: str) -> None:
    """Switch to the git mirror backend when the RPC endpoint fails."""
    global USE_AUR_RPC, _RPC_FALLBACK_NOTIFIED
    if FORCE_GIT_MIRROR or not USE_AUR_RPC:
        return
    USE_AUR_RPC = False
    if _RPC_FALLBACK_NOTIFIED:
        return
    summary = reason.strip().splitlines()[0] if reason else "unknown error"
    message = f"AUR RPC unavailable ({summary}); falling back to git mirror."
    print(style(message, YELLOW), file=sys.stderr)
    _RPC_FALLBACK_NOTIFIED = True


def prompt_confirm(message: str) -> bool:
    if not sys.stdin.isatty():
        return False
    try:
        response = input(message)
    except EOFError:
        return False
    return response.strip().lower() in {"y", "yes"}


def is_debug_package(name: str) -> bool:
    return name.endswith("-debug")


def is_vcs_package(name: str) -> bool:
    return any(name.endswith(suffix) for suffix in _VCS_SUFFIXES)


class AurGitError(RuntimeError):
    """Wraps fatal errors coming from the helper."""


@dataclass(frozen=True)
class DependencySet:
    depends: Set[str]
    makedepends: Set[str]
    checkdepends: Set[str]
    optdepends: Set[str]

    @property
    def all_build_deps(self) -> Set[str]:
        return self.depends | self.makedepends


@dataclass(frozen=True)
class SearchResult:
    name: str
    version: Optional[str]
    description: Optional[str]
    installed: bool
    score: int
    votes: Optional[int] = None
    is_orphan: Optional[bool] = None


@dataclass(frozen=True)
class UpdateCandidate:
    name: str
    installed_version: Optional[str]
    target_version: Optional[str]
    remote_head: Optional[str]
    local_head: Optional[str]


def aur_rpc_call(params: Dict[str, Any]) -> Dict[str, Any]:
    query_params: Dict[str, Any] = {"v": "5"}
    query_params.update(params)
    query = urllib.parse.urlencode(query_params, doseq=True)
    url = f"{AUR_RPC_ENDPOINT}?{query}"
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            status = response.getcode()
            if status != 200:
                disable_aur_rpc(f"status {status}")
                raise AurGitError(f"AUR RPC request failed with status {status}")
            payload = response.read()
    except urllib.error.URLError as exc:
        disable_aur_rpc(str(exc))
        raise AurGitError(f"Failed to contact AUR RPC: {exc}") from exc
    except Exception as exc:  # pragma: no cover - unexpected transport issues
        disable_aur_rpc(str(exc))
        raise AurGitError(f"Failed to contact AUR RPC: {exc}") from exc
    try:
        data = json.loads(payload.decode())
    except (UnicodeDecodeError, json.JSONDecodeError) as exc:
        disable_aur_rpc("invalid JSON payload")
        raise AurGitError("Failed to decode AUR RPC response") from exc
    if data.get("type") == "error":
        raise AurGitError(str(data.get("error") or "Unknown AUR RPC error"))
    return data


def aur_rpc_info(package: str) -> Optional[dict]:
    if package in _AUR_INFO_CACHE:
        return _AUR_INFO_CACHE[package]
    try:
        data = aur_rpc_call({"type": "info", "arg[]": [package]})
    except AurGitError:
        _AUR_INFO_CACHE[package] = None
        return None
    results = data.get("results")
    match: Optional[dict] = None
    if isinstance(results, list):
        for entry in results:
            if isinstance(entry, dict) and entry.get("Name") == package:
                match = entry
                break
        if match is None:
            for entry in results:
                if isinstance(entry, dict) and entry.get("PackageBase") == package:
                    match = entry
                    break
    _AUR_INFO_CACHE[package] = match
    return match


def dependency_set_from_rpc(info: dict) -> DependencySet:
    def gather(key: str, normalize: bool = True) -> Set[str]:
        values: Set[str] = set()
        items = info.get(key)
        if not isinstance(items, list):
            return values
        for item in items:
            if not isinstance(item, str):
                continue
            entry = _normalize_dep(item) if normalize else item.strip()
            if entry:
                values.add(entry)
        return values

    depends = gather("Depends")
    makedepends = gather("MakeDepends")
    checkdepends = gather("CheckDepends")
    optdepends = gather("OptDepends", normalize=False)
    return DependencySet(depends, makedepends, checkdepends, optdepends)


def aur_rpc_search_results(pattern: str) -> List[dict]:
    try:
        data = aur_rpc_call({"type": "search", "arg": pattern})
    except AurGitError:
        return []
    results = data.get("results")
    if not isinstance(results, list):
        return []
    return [entry for entry in results if isinstance(entry, dict)]


def aur_rpc_suggest(prefix: str) -> List[str]:
    try:
        data = aur_rpc_call({"type": "suggest", "arg": prefix})
    except AurGitError:
        return []
    results = data.get("results")
    if not isinstance(results, list):
        return []
    suggestions: List[str] = []
    for entry in results:
        if isinstance(entry, str):
            suggestions.append(entry)
    return suggestions


def run_command(
    cmd: Sequence[str],
    *,
    cwd: Optional[Path] = None,
    capture: bool = False,
    check: bool = True,
    env: Optional[dict] = None,
) -> subprocess.CompletedProcess | str:
    """Run a command, optionally capturing stdout, and surface errors nicely."""
    try:
        completed = subprocess.run(
            list(cmd),
            cwd=str(cwd) if cwd else None,
            check=check,
            text=True,
            capture_output=capture,
            env=env,
        )
    except FileNotFoundError as exc:  # e.g. git not installed
        raise AurGitError(f"Required command not found: {cmd[0]}") from exc
    except subprocess.CalledProcessError as exc:
        raise AurGitError(
            f"Command failed with exit code {exc.returncode}: {' '.join(cmd)}\n{exc.stderr or ''}"
        ) from exc

    if capture:
        return completed.stdout
    return completed


def ensure_clone(
    package: str,
    dest_root: Path,
    *,
    refresh: bool = False,
    force_reclone: bool = False,
) -> Path:
    """Clone or refresh the package branch into dest_root/package."""
    dest_root.mkdir(parents=True, exist_ok=True)
    package_dir = dest_root / package

    if package_dir.exists() and not (package_dir / ".git").is_dir():
        if force_reclone:
            shutil.rmtree(package_dir)
        else:
            raise AurGitError(
                f"Destination '{package_dir}' exists but is not a git repository. "
                "Use --force to overwrite."
            )

    if USE_AUR_RPC:
        remote_url = f"{OFFICIAL_AUR_GIT_BASE}/{package}.git"
        if package_dir.exists() and (package_dir / ".git").is_dir() and not force_reclone:
            if refresh:
                run_command(["git", "-C", str(package_dir), "fetch", "origin"])
                try:
                    _reset_git_worktree(
                        package_dir,
                        (
                            "origin/HEAD",
                            "origin/master",
                            "origin/main",
                            f"origin/{package}",
                        ),
                    )
                except AurGitError:
                    if package_dir.exists():
                        shutil.rmtree(package_dir)
                    return ensure_clone(
                        package,
                        dest_root,
                        refresh=False,
                        force_reclone=True,
                    )
            return package_dir
        if package_dir.exists():
            shutil.rmtree(package_dir)
        run_command(["git", "clone", remote_url, str(package_dir)])
    else:
        if package_dir.exists() and (package_dir / ".git").is_dir() and not force_reclone:
            if refresh:
                run_command(["git", "-C", str(package_dir), "fetch", "origin", package])
                try:
                    _reset_git_worktree(package_dir, (f"origin/{package}",))
                except AurGitError:
                    if package_dir.exists():
                        shutil.rmtree(package_dir)
                    return ensure_clone(
                        package,
                        dest_root,
                        refresh=False,
                        force_reclone=True,
                    )
            return package_dir
        if package_dir.exists():
            shutil.rmtree(package_dir)
        run_command(
            [
                "git",
                "clone",
                "--branch",
                package,
                "--single-branch",
                AUR_REMOTE,
                str(package_dir),
            ]
        )

    return package_dir


def read_srcinfo(package_dir: Path) -> str:
    srcinfo_path = package_dir / ".SRCINFO"
    if srcinfo_path.exists():
        return srcinfo_path.read_text()
    # Fallback to generating on the fly
    output = run_command(["makepkg", "--printsrcinfo"], cwd=package_dir, capture=True)
    return str(output)


_SRCINFO_KEYS = {"depends", "makedepends", "checkdepends", "optdepends", "pkgname", "pkgbase", "pkgdesc"}


def parse_dependencies(srcinfo_content: str) -> tuple[str, str | None, DependencySet]:
    pkgbase = ""
    pkgdesc = None
    depends: Set[str] = set()
    makedepends: Set[str] = set()
    checkdepends: Set[str] = set()
    optdepends: Set[str] = set()

    for raw_line in srcinfo_content.splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key not in _SRCINFO_KEYS:
            continue
        if key == "pkgbase" and not pkgbase:
            pkgbase = value
            continue
        if key == "pkgdesc" and not pkgdesc:
            pkgdesc = value
            continue
        if key == "optdepends":
            optdepends.add(value)
            continue
        if key == "depends":
            depends.update([_normalize_dep(value)])
        elif key == "makedepends":
            makedepends.update([_normalize_dep(value)])
        elif key == "checkdepends":
            checkdepends.update([_normalize_dep(value)])

    if not pkgbase:
        raise AurGitError("Failed to parse pkgbase from .SRCINFO")
    return pkgbase, pkgdesc, DependencySet(depends, makedepends, checkdepends, optdepends)


_DEP_SPLIT_RE = re.compile(r"[<>~=]+")


def _normalize_dep(dep_entry: str) -> str:
    dep_entry = dep_entry.strip()
    if not dep_entry:
        return dep_entry
    dep_entry = dep_entry.split(":", 1)[-1]  # strip repo qualifier if present
    dep_entry = _DEP_SPLIT_RE.split(dep_entry)[0]
    return dep_entry.strip()


def _pkgbase_guesses(dep: str) -> List[str]:
    """Return possible pkgbase names for split packages sharing a prefix."""
    parts = dep.split("-")
    guesses: List[str] = []
    # Walk backwards dropping the last segment each time (foo-bar-baz -> foo-bar, foo)
    for index in range(len(parts) - 1, 0, -1):
        candidate = "-".join(parts[:index])
        if candidate:
            guesses.append(candidate)
    return guesses


def _parse_srcinfo_metadata(srcinfo_content: str) -> tuple[Optional[str], Optional[str]]:
    pkgver = None
    pkgrel = None
    epoch = None
    description = None
    for raw_line in srcinfo_content.splitlines():
        line = raw_line.strip()
        if not line or "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key == "pkgver" and not pkgver:
            pkgver = value
        elif key == "pkgrel" and not pkgrel:
            pkgrel = value
        elif key == "epoch" and not epoch:
            epoch = value
        elif key == "pkgdesc" and not description:
            description = value
    if pkgver or pkgrel or epoch:
        version_parts: List[str] = []
        if epoch and epoch not in {"", "0"}:
            version_parts.append(f"{epoch}:")
        if pkgver:
            version_parts.append(pkgver)
        if pkgrel and pkgver:
            version_parts.append(f"-{pkgrel}")
        version = "".join(version_parts) if version_parts else None
    else:
        version = None
    return version, description


def _reset_git_worktree(package_dir: Path, refs: Sequence[str]) -> None:
    for ref in refs:
        try:
            run_command([
                "git",
                "-C",
                str(package_dir),
                "rev-parse",
                "--verify",
                ref,
            ], capture=True)
        except AurGitError:
            continue
        run_command([
            "git",
            "-C",
            str(package_dir),
            "reset",
            "--hard",
            ref,
        ])
        return
    raise AurGitError(
        f"Could not reset {package_dir.name} to any of: {', '.join(refs)}"
    )


def compute_match_score(
    name: str,
    *,
    regex: Optional[re.Pattern],
    needle: Optional[str],
) -> Optional[int]:
    if regex is not None:
        match = regex.search(name)
        if not match:
            return None
        start = match.start()
        span = match.end() - match.start()
    else:
        if needle is None:
            raise ValueError("needle required when regex is None")
        lowered = name.lower()
        idx = lowered.find(needle)
        if idx == -1:
            return None
        start = idx
        span = len(needle)
    # Lower score is better match
    return start * 1000 + len(name) - span


def _pacman_returns_zero(args: Sequence[str]) -> bool:
    try:
        proc = subprocess.run(
            list(args),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except FileNotFoundError as exc:
        raise AurGitError("pacman command not found; this tool must run on Arch Linux") from exc
    return proc.returncode == 0


def invalidate_installed_cache() -> None:
    global _INSTALLED_CACHE
    _INSTALLED_CACHE = None


def installed_package_set() -> Set[str]:
    global _INSTALLED_CACHE
    if _INSTALLED_CACHE is None:
        output = run_command(["pacman", "-Qq"], capture=True)
        _INSTALLED_CACHE = set(str(output).split())
    return _INSTALLED_CACHE


def is_installed(package: str) -> bool:
    return package in installed_package_set()


def exists_in_sync_repo(package: str) -> bool:
    return _pacman_returns_zero(["pacman", "-Si", package])


def is_dependency_satisfied(dep: str) -> bool:
    try:
        proc = subprocess.run(
            ["pacman", "-T", dep],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except FileNotFoundError as exc:
        raise AurGitError("pacman command not found; this tool must run on Arch Linux") from exc
    return proc.returncode == 0


def package_provides(package: str) -> Optional[Set[str]]:
    if package in _PROVIDES_CACHE:
        return _PROVIDES_CACHE[package]
    provides: Set[str] = set()
    info: Optional[dict] = None
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            name = info.get("Name")
            if isinstance(name, str):
                normalized = _normalize_dep(name)
                if normalized:
                    provides.add(normalized)
            pkgbase_value = info.get("PackageBase")
            if isinstance(pkgbase_value, str):
                normalized = _normalize_dep(pkgbase_value)
                if normalized:
                    provides.add(normalized)
            rpc_provides = info.get("Provides")
            if isinstance(rpc_provides, list):
                for value in rpc_provides:
                    if not isinstance(value, str):
                        continue
                    normalized = _normalize_dep(value)
                    if normalized:
                        provides.add(normalized)
    srcinfo = fetch_git_file(package, ".SRCINFO")
    if not srcinfo:
        if not provides:
            _PROVIDES_CACHE[package] = None
            return None
        _PROVIDES_CACHE[package] = provides
        return provides
    for raw_line in srcinfo.splitlines():
        line = raw_line.strip()
        if not line or "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key == "pkgname" or key == "provides":
            normalized = _normalize_dep(value)
            if normalized:
                provides.add(normalized)
    _PROVIDES_CACHE[package] = provides
    return provides


def _search_aur_candidates(dep: str, *, limit: int = 25) -> List[str]:
    if USE_AUR_RPC:
        results = _search_aur_candidates_rpc(dep, limit=limit)
        if results or USE_AUR_RPC:
            return results
    patterns = [
        f"refs/heads/{dep}",
        f"refs/heads/{dep}-*",
        f"refs/heads/*-{dep}",
    ]
    if len(dep) >= 3:
        patterns.append(f"refs/heads/*{dep}*")
    seen: Set[str] = set()
    results: List[str] = []
    for pattern in patterns:
        try:
            output = run_command(
                ["git", "ls-remote", "--heads", AUR_REMOTE, pattern],
                capture=True,
            )
        except AurGitError:
            continue
        for raw_line in str(output).splitlines():
            parts = raw_line.split()
            if len(parts) != 2:
                continue
            ref = parts[1]
            name = ref.split("/")[-1]
            if not name or name in seen:
                continue
            seen.add(name)
            results.append(name)
            if len(results) >= limit:
                return results
    return results


def _search_aur_candidates_rpc(dep: str, *, limit: int) -> List[str]:
    results = aur_rpc_search_results(dep)
    seen: Set[str] = set()
    names: List[str] = []
    for entry in results:
        for key in ("Name", "PackageBase"):
            value = entry.get(key)
            if not isinstance(value, str):
                continue
            if value in seen:
                continue
            seen.add(value)
            names.append(value)
            if len(names) >= limit:
                return names
    return names


def resolve_aur_dependency(dep: str) -> Optional[str]:
    if dep in _VIRTUAL_PROVIDER_CACHE:
        return _VIRTUAL_PROVIDER_CACHE[dep]
    if exists_in_aur_mirror(dep):
        _VIRTUAL_PROVIDER_CACHE[dep] = dep
        return dep
    candidates: List[str] = []
    seen: Set[str] = set()

    def add_candidate(name: str) -> None:
        if not name or name in seen:
            return
        seen.add(name)
        candidates.append(name)

    add_candidate(dep)
    for suffix in (*_VCS_SUFFIXES, *_COMMON_AUR_SUFFIXES):
        add_candidate(f"{dep}{suffix}")
    for base_candidate in _pkgbase_guesses(dep):
        add_candidate(base_candidate)
    for candidate in candidates:
        provides = package_provides(candidate)
        if not provides:
            continue
        if dep in provides:
            _VIRTUAL_PROVIDER_CACHE[dep] = candidate
            return candidate
    search_terms = [dep, *(_pkgbase_guesses(dep))]
    seen_search: Set[str] = set()
    for term in search_terms:
        if term in seen_search:
            continue
        seen_search.add(term)
        for candidate in _search_aur_candidates(term):
            if candidate in seen:
                continue
            seen.add(candidate)
            provides = package_provides(candidate)
            if not provides:
                continue
            if dep in provides:
                _VIRTUAL_PROVIDER_CACHE[dep] = candidate
                return candidate
    _VIRTUAL_PROVIDER_CACHE[dep] = None
    return None


def resolve_official_dependency(dep: str) -> Optional[str]:
    """Return the repo package that satisfies dep, accounting for providers."""
    if exists_in_sync_repo(dep):
        return dep
    try:
        output = run_command(
            [
                "pacman",
                "-Sp",
                "--print-format",
                "%n",
                dep,
            ],
            capture=True,
        )
    except AurGitError:
        return None
    providers = [line.strip() for line in str(output).splitlines() if line.strip()]
    if not providers:
        return None
    return providers[0]


def exists_in_aur_mirror(package: str) -> bool:
    if is_debug_package(package):
        return True
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            return True
        if USE_AUR_RPC:
            return False
    try:
        output = run_command([
            "git",
            "ls-remote",
            "--heads",
            AUR_REMOTE,
            package,
        ], capture=True)
    except AurGitError:
        return False
    return bool(str(output).strip())


def list_foreign_packages() -> dict[str, str]:
    output = run_command(["pacman", "-Qm"], capture=True)
    names: dict[str, str] = {}
    for line in str(output).splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) >= 2:
            names[parts[0]] = parts[1]
        else:
            names[parts[0]] = ""
    return names


def get_local_head(package_dir: Path) -> Optional[str]:
    if not (package_dir / ".git").is_dir():
        return None
    try:
        output = run_command(["git", "-C", str(package_dir), "rev-parse", "HEAD"], capture=True)
    except AurGitError:
        return None
    return str(output).strip() or None


def get_remote_head(package: str) -> Optional[str]:
    try:
        if USE_AUR_RPC:
            output = run_command(
                [
                    "git",
                    "ls-remote",
                    f"{OFFICIAL_AUR_GIT_BASE}/{package}.git",
                    "HEAD",
                ],
                capture=True,
            )
        else:
            output = run_command(
                [
                    "git",
                    "ls-remote",
                    "--heads",
                    AUR_REMOTE,
                    package,
                ],
                capture=True,
            )
    except AurGitError:
        return None
    for line in str(output).splitlines():
        parts = line.split()
        if not parts:
            continue
        sha = parts[0]
        if sha:
            return sha
    return None


def get_installed_version(package: str) -> Optional[str]:
    try:
        output = run_command(["pacman", "-Qi", package], capture=True)
    except AurGitError:
        return None
    for line in str(output).splitlines():
        if line.lower().startswith("version"):
            _, value = line.split(":", 1)
            return value.strip()
    return None


def fetch_git_file(package: str, path: str) -> Optional[str]:
    safe_package = urllib.parse.quote(package)
    safe_path = path.lstrip("/")
    if USE_AUR_RPC:
        url = f"{CGIT_RAW_BASE}/{safe_path}?h={safe_package}"
    else:
        url = f"{GITHUB_RAW_BASE}/{safe_package}/{safe_path}"
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            if response.status != 200:
                return None
            data = response.read()
    except urllib.error.URLError:
        return None
    try:
        return data.decode()
    except UnicodeDecodeError:
        return None


def git_srcinfo_metadata(package: str) -> Optional[tuple[str, Optional[str]]]:
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if not info:
            return None
        version = info.get("Version")
        description = info.get("Description")
        if isinstance(version, str) or isinstance(description, str):
            return (version if isinstance(version, str) else None, description if isinstance(description, str) else None)
        # fallback to raw .SRCINFO if fields missing
    srcinfo = fetch_git_file(package, ".SRCINFO")
    if not srcinfo:
        return None
    version, description = _parse_srcinfo_metadata(srcinfo)
    if not version and not description:
        return None
    return version, description


def install_official_packages(packages: Iterable[str], *, noconfirm: bool) -> None:
    pkgs = sorted(set(packages))
    if not pkgs:
        return
    cmd: List[str] = ["pacman", "-S", "--needed"]
    if noconfirm:
        cmd.append("--noconfirm")
    cmd.extend(pkgs)
    if os.geteuid() != 0:
        cmd.insert(0, "sudo")
    print(f"Installing official packages: {' '.join(pkgs)}")
    run_command(cmd)
    invalidate_installed_cache()


def collect_missing_official_packages(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    visited: Optional[Set[str]] = None,
) -> tuple[Set[str], Set[str]]:
    """Return official packages missing for the dependency tree rooted at package."""
    visited = visited or set()
    if package in visited:
        return set(), set()
    visited.add(package)

    info: Optional[dict] = None
    deps: Optional[DependencySet] = None
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            deps = dependency_set_from_rpc(info)
    if deps is None:
        package_dir = ensure_clone(package, dest_root, refresh=refresh)
        srcinfo = read_srcinfo(package_dir)
        _, _, deps = parse_dependencies(srcinfo)

    missing_official: Set[str] = set()
    unresolved: Set[str] = set()

    for dep in sorted(deps.all_build_deps):
        if dep == package:
            continue
        if is_dependency_satisfied(dep):
            continue
        provider = resolve_official_dependency(dep)
        if provider:
            missing_official.add(provider)
            continue
        aur_provider = resolve_aur_dependency(dep)
        if aur_provider:
            child_missing, child_unresolved = collect_missing_official_packages(
                aur_provider,
                dest_root,
                refresh=refresh,
                visited=visited,
            )
            missing_official.update(child_missing)
            unresolved.update(child_unresolved)
            continue
        if _pacman_returns_zero(["pacman", "-Sp", dep]):
            missing_official.add(dep)
            continue
        unresolved.add(dep)

    return missing_official, unresolved


def build_and_install(package_dir: Path, *, noconfirm: bool) -> None:
    pkgbuild_path = package_dir / "PKGBUILD"
    if not pkgbuild_path.exists():
        raise AurGitError(f"PKGBUILD missing at {pkgbuild_path}")
    cmd = ["makepkg", "-si", "--needed"]
    if noconfirm:
        cmd.append("--noconfirm")
    print(f"Building {package_dir.name} with makepkg")
    run_command(cmd, cwd=package_dir)
    print(f"Built package artifacts remain under {package_dir}")
    invalidate_installed_cache()


def install_package(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    noconfirm: bool,
    visited: Optional[Set[str]] = None,
    preinstalled_official: Optional[Set[str]] = None,
) -> None:
    visited = visited or set()
    if package in visited:
        return
    visited.add(package)

    if preinstalled_official is None:
        preinstalled_official = set()

    package_dir: Optional[Path] = None
    info: Optional[dict] = None
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info is None and USE_AUR_RPC:
            raise AurGitError(f"Package '{package}' not found via AUR RPC")
    if info:
        pkgdesc = info.get("Description") if isinstance(info.get("Description"), str) else None
        deps = dependency_set_from_rpc(info)
    else:
        package_dir = ensure_clone(package, dest_root, refresh=refresh)
        srcinfo = read_srcinfo(package_dir)
        _, pkgdesc, deps = parse_dependencies(srcinfo)
    if pkgdesc:
        print(f"==> {package}: {pkgdesc}")
    else:
        print(f"==> {package}")

    missing_official: Set[str] = set()
    aur_dependencies: Set[str] = set()
    unresolved: Set[str] = set()
    virtual_providers: dict[str, Set[str]] = {}
    for dep in sorted(deps.all_build_deps):
        if dep == package:
            continue
        if is_dependency_satisfied(dep):
            continue
        provider = resolve_official_dependency(dep)
        if provider:
            missing_official.add(provider)
            continue
        aur_provider = resolve_aur_dependency(dep)
        if aur_provider:
            aur_dependencies.add(aur_provider)
            if aur_provider != dep:
                virtual_providers.setdefault(aur_provider, set()).add(dep)
            continue
        if _pacman_returns_zero(["pacman", "-Sp", dep]):
            missing_official.add(dep)
            continue
        unresolved.add(dep)

    if unresolved:
        missing_list = ", ".join(sorted(unresolved))
        raise AurGitError(f"Could not resolve providers for: {missing_list}")

    if missing_official:
        to_install = missing_official - preinstalled_official
        if to_install:
            install_official_packages(to_install, noconfirm=noconfirm)
            preinstalled_official.update(to_install)

    if aur_dependencies and not noconfirm:
        print(style("The following AUR dependencies are required:", CYAN))
        for dep_pkg in sorted(aur_dependencies):
            provides = virtual_providers.get(dep_pkg)
            if provides:
                provides_label = ", ".join(sorted(provides))
                print(f"  {dep_pkg} (provides {provides_label})")
            else:
                print(f"  {dep_pkg}")
        if not prompt_confirm(style("Proceed with building these dependencies? [y/N]: ", YELLOW)):
            raise AurGitError("Installation aborted by user")

    for aur_dep in sorted(aur_dependencies):
        install_package(
            aur_dep,
            dest_root,
            refresh=refresh,
            noconfirm=noconfirm,
            visited=visited,
            preinstalled_official=preinstalled_official,
        )

    if package_dir is None:
        package_dir = ensure_clone(package, dest_root, refresh=refresh)

    build_and_install(package_dir, noconfirm=noconfirm)


def update_packages(
    dest_root: Path,
    *,
    refresh: bool,
    noconfirm: bool,
    include_devel: bool,
    targets: Optional[Sequence[str]] = None,
) -> None:
    candidates: List[tuple[str, Optional[str]]]
    if targets:
        seen: Set[str] = set()
        candidates = []
        for pkg in targets:
            if pkg in seen:
                continue
            seen.add(pkg)
            candidates.append((pkg, get_installed_version(pkg)))
    else:
        foreign = list_foreign_packages()
        if not foreign:
            print("No foreign packages reported by pacman -Qm")
            return
        candidates = list(foreign.items())

    missing: List[str] = []
    pending_updates: List[UpdateCandidate] = []
    skip_devel = not include_devel and not targets

    for package, installed_version in candidates:
        if is_debug_package(package):
            continue
        if skip_devel and is_vcs_package(package):
            continue

        remote_version: Optional[str] = None
        remote_head: Optional[str] = None
        local_head: Optional[str] = None

        meta = git_srcinfo_metadata(package)
        if meta:
            remote_version = meta[0]

        if remote_version and is_vcs_package(package):
            remote_version = None

        if remote_version is None:
            remote_head = get_remote_head(package)
            if remote_head is None:
                missing.append(package)
                continue
            package_dir = dest_root / package
            local_head = get_local_head(package_dir)

        if installed_version and remote_version and installed_version == remote_version:
            continue

        if remote_head:
            package_dir = dest_root / package
            if local_head is None:
                local_head = get_local_head(package_dir)
            if local_head and local_head == remote_head:
                continue

        pending_updates.append(
            UpdateCandidate(
                name=package,
                installed_version=installed_version,
                target_version=remote_version,
                remote_head=remote_head,
                local_head=local_head,
            )
        )

    if not pending_updates:
        print("All packages are up to date.")
        if missing:
            source_label = "AUR RPC" if USE_AUR_RPC else "AUR mirror"
            for package in missing:
                print(f"note: {package} is not available via {source_label}", file=sys.stderr)
        return

    for index, candidate in enumerate(pending_updates, start=1):
        from_version = candidate.installed_version or "?"
        if candidate.target_version:
            to_version = candidate.target_version
        elif candidate.remote_head:
            to_version = candidate.remote_head[:7]
        else:
            to_version = "unknown"
        print(f"{index}) {candidate.name} {from_version} -> {to_version}")

    interactive = sys.stdin.isatty() and sys.stdout.isatty()
    if interactive:
        selected_candidates = interactive_select_updates(pending_updates)
        if not selected_candidates:
            return
    else:
        selected_candidates = pending_updates

    shared_visited: Set[str] = set()
    shared_preinstalled_official: Set[str] = set()
    for candidate in selected_candidates:
        try:
            install_package(
                candidate.name,
                dest_root,
                refresh=refresh,
                noconfirm=noconfirm,
                visited=shared_visited,
                preinstalled_official=shared_preinstalled_official,
            )
        except AurGitError as exc:
            print(f"error updating {candidate.name}: {exc}", file=sys.stderr)

    for package in missing:
        if is_debug_package(package):
            continue
        source_label = "AUR RPC" if USE_AUR_RPC else "AUR mirror"
        print(f"note: {package} is not available via {source_label}", file=sys.stderr)


def search_packages(
    pattern: str,
    *,
    regex: Optional[re.Pattern],
    needle: Optional[str],
    limit: Optional[int],
) -> List[SearchResult]:
    if USE_AUR_RPC:
        results = search_packages_rpc(
            pattern,
            regex=regex,
            needle=needle,
            limit=limit,
        )
        if results or USE_AUR_RPC:
            return results
    return search_packages_git(
        pattern,
        regex=regex,
        needle=needle,
        limit=limit,
    )


def search_packages_git(
    pattern: str,
    *,
    regex: Optional[re.Pattern],
    needle: Optional[str],
    limit: Optional[int],
) -> List[SearchResult]:
    output = run_command(["git", "ls-remote", "--heads", AUR_REMOTE], capture=True)
    candidates: List[tuple[int, str]] = []
    for line in str(output).splitlines():
        if not line.strip():
            continue
        try:
            _, ref = line.split()
        except ValueError:
            continue
        package = ref.split("/")[-1]
        score = compute_match_score(package, regex=regex, needle=needle)
        if score is None:
            continue
        candidates.append((score, package))
    candidates.sort(key=lambda item: (item[0], item[1]))
    if limit is not None and limit >= 0:
        candidates = candidates[:limit]
    installed_set = installed_package_set()
    results: List[SearchResult] = []
    for score, package in candidates:
        version = None
        description = None
        meta = git_srcinfo_metadata(package)
        if meta:
            version, description = meta
        results.append(
            SearchResult(
                name=package,
                version=version,
                description=description,
                installed=package in installed_set,
                score=score,
            )
        )
    return results


def search_packages_rpc(
    pattern: str,
    *,
    regex: Optional[re.Pattern],
    needle: Optional[str],
    limit: Optional[int],
) -> List[SearchResult]:
    raw_results = aur_rpc_search_results(pattern)
    candidates: List[tuple[int, dict]] = []
    for entry in raw_results:
        name = entry.get("Name")
        if not isinstance(name, str):
            continue
        score = compute_match_score(name, regex=regex, needle=needle)
        if score is None:
            continue
        candidates.append((score, entry))
    candidates.sort(key=lambda item: (item[0], item[1].get("Name", "")))
    if limit is not None and limit >= 0:
        candidates = candidates[:limit]
    installed_set = installed_package_set()
    results: List[SearchResult] = []
    for score, entry in candidates:
        name_value = entry.get("Name")
        if not isinstance(name_value, str):
            continue
        version = entry.get("Version") if isinstance(entry.get("Version"), str) else None
        description = entry.get("Description") if isinstance(entry.get("Description"), str) else None
        votes = None
        votes_value = entry.get("NumVotes")
        if isinstance(votes_value, (int, float, str)):
            try:
                votes = int(votes_value)
            except (TypeError, ValueError):
                votes = None
        maintainer = entry.get("Maintainer")
        is_orphan = maintainer in (None, "")
        results.append(
            SearchResult(
                name=name_value,
                version=version,
                description=description,
                installed=name_value in installed_set,
                score=score,
                votes=votes,
                is_orphan=is_orphan,
            )
        )
    return results


def order_search_results(results: Sequence[SearchResult]) -> List[SearchResult]:
    # Lower score = better match; return ascending order (best last when reversed later).
    return sorted(results, key=lambda result: (result.score, result.name))


def format_search_result(index: int, result: SearchResult) -> List[str]:
    index_label = style(f"{index:>2})", CYAN)
    main_parts: List[str] = [style(result.name, BOLD)]
    if result.version:
        main_parts.append(style(result.version, GREEN))
    if result.installed:
        main_parts.append(style("[installed]", GREEN))
    if USE_AUR_RPC:
        meta_bits: List[str] = ["aur rpc"]
        if result.votes is not None:
            meta_bits.append(f"{result.votes} votes")
        if result.is_orphan:
            meta_bits.append("orphan")
    else:
        meta_bits = ["git mirror"]
    line = f"{index_label} {' '.join(main_parts)}"
    if meta_bits:
        line += f" {style('[' + ', '.join(meta_bits) + ']', DIM)}"
    lines = [line]
    if result.description:
        lines.append(f"    {style(result.description, DIM)}")
    return lines


def print_search_results(results: Sequence[SearchResult]) -> None:
    total = len(results)
    for pos, result in enumerate(results):
        display_index = total - pos
        for line in format_search_result(display_index, result):
            print(line)


def format_update_candidate(index: int, candidate: UpdateCandidate) -> List[str]:
    index_label = style(f"{index:>2})", CYAN)
    name_part = style(candidate.name, BOLD)
    current_version = candidate.installed_version or "?"
    if candidate.target_version:
        target_label = candidate.target_version
    elif candidate.remote_head:
        target_label = f"{candidate.remote_head[:7]}"
    else:
        target_label = "unknown"
    change = f"{current_version} -> {target_label}"
    meta_bits: List[str] = []
    if candidate.remote_head and not candidate.target_version:
        meta_bits.append("git commit")
    line = f"{index_label} {name_part} {style(change, GREEN)}"
    if meta_bits:
        line += f" {style('[' + ', '.join(meta_bits) + ']', DIM)}"
    return [line]


def interactive_select_updates(candidates: Sequence[UpdateCandidate]) -> List[UpdateCandidate]:
    if not candidates:
        return []
    prompt_text = style(
        "Select packages to update (Enter for all, q to quit): ",
        YELLOW,
    )
    total = len(candidates)
    while True:
        try:
            raw = input(prompt_text)
        except EOFError:
            return list(candidates)
        if not raw.strip():
            return list(candidates)
        parsed = parse_selection(raw, total)
        if parsed is None:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        if not parsed:
            return []
        selected: List[UpdateCandidate] = []
        for value in parsed:
            index = value - 1
            if index < 0 or index >= total:
                selected = []
                break
            selected.append(candidates[index])
        if not selected and parsed:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        return selected


def parse_selection(selection: str, max_index: int) -> Optional[List[int]]:
    selection = selection.strip().lower()
    if not selection:
        return []
    if selection in {"q", "quit"}:
        return []
    if selection in {"a", "all"}:
        return list(range(1, max_index + 1))
    chosen: Set[int] = set()
    tokens = re.split(r"[\s,]+", selection)
    for token in tokens:
        if not token:
            continue
        if "-" in token:
            start_str, end_str = token.split("-", 1)
            try:
                start = int(start_str)
                end = int(end_str)
            except ValueError:
                return None
            if start > end:
                start, end = end, start
            if start < 1 or end > max_index:
                return None
            chosen.update(range(start, end + 1))
            continue
        try:
            value = int(token)
        except ValueError:
            return None
        if value < 1 or value > max_index:
            return None
        chosen.add(value)
    return sorted(chosen)


def interactive_select_results(results: Sequence[SearchResult]) -> List[SearchResult]:
    if not results:
        return []
    total = len(results)
    prompt_text = style(
        "Select packages to install (e.g. 1 3-5, a for all, q to quit): ",
        YELLOW,
    )
    while True:
        try:
            raw = input(prompt_text)
        except EOFError:
            return []
        parsed = parse_selection(raw, total)
        if parsed is None:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        if not parsed:
            return []
        selected: List[SearchResult] = []
        for value in parsed:
            index = total - value
            selected.append(results[index])
        return selected


def complete_packages(prefix: str, limit: int) -> List[str]:
    if USE_AUR_RPC:
        names = complete_packages_rpc(prefix, limit)
        if names or USE_AUR_RPC:
            return names
    return complete_packages_git(prefix, limit)


def complete_packages_git(prefix: str, limit: int) -> List[str]:
    prefix = prefix.strip()
    if not prefix:
        return []
    pattern = f"refs/heads/{prefix}*"
    try:
        output = run_command(
            ["git", "ls-remote", "--heads", AUR_REMOTE, pattern],
            capture=True,
        )
    except AurGitError:
        return []
    names: List[str] = []
    for line in str(output).splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) != 2:
            continue
        ref = parts[1]
        name = ref.split("/")[-1]
        names.append(name)
        if len(names) >= limit:
            break
    return names


def complete_packages_rpc(prefix: str, limit: int) -> List[str]:
    prefix = prefix.strip()
    if not prefix:
        return []
    suggestions = aur_rpc_suggest(prefix)
    names: List[str] = []
    seen: Set[str] = set()
    for suggestion in suggestions:
        if not suggestion.startswith(prefix):
            continue
        if suggestion in seen:
            continue
        seen.add(suggestion)
        names.append(suggestion)
        if len(names) >= limit:
            break
    return names


def inspect_package(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    target: str,
    show_deps: bool,
) -> None:
    if USE_AUR_RPC and target == "info":
        info = aur_rpc_info(package)
        if info:
            deps = dependency_set_from_rpc(info)
            print(f"Package: {package}")
            description = info.get("Description") if isinstance(info.get("Description"), str) else None
            if description:
                print(f"Description: {description}")
            if deps.depends:
                print("Depends:")
                for dep in sorted(deps.depends):
                    print(f"  {dep}")
            else:
                print("Depends: (none)")
            if show_deps:
                if deps.makedepends:
                    print("Make depends:")
                    for dep in sorted(deps.makedepends):
                        print(f"  {dep}")
                else:
                    print("Make depends: (none)")
                if deps.checkdepends:
                    print("Check depends:")
                    for dep in sorted(deps.checkdepends):
                        print(f"  {dep}")
                else:
                    print("Check depends: (none)")
                if deps.optdepends:
                    print("Optional:")
                    for dep in sorted(deps.optdepends):
                        print(f"  {dep}")
                else:
                    print("Optional: (none)")
            return
        if USE_AUR_RPC:
            raise AurGitError(f"Package '{package}' not found via AUR RPC")

    package_dir = ensure_clone(package, dest_root, refresh=refresh)
    if target == "PKGBUILD":
        pkgbuild_path = package_dir / "PKGBUILD"
        if not pkgbuild_path.exists():
            raise AurGitError(f"PKGBUILD not found at {pkgbuild_path}")
        print(pkgbuild_path.read_text())
        return
    if target == "SRCINFO":
        print(read_srcinfo(package_dir))
        return

    srcinfo = read_srcinfo(package_dir)
    _, pkgdesc, deps = parse_dependencies(srcinfo)
    print(f"Package: {package}")
    if pkgdesc:
        print(f"Description: {pkgdesc}")
    if deps.depends:
        print("Depends:")
        for dep in sorted(deps.depends):
            print(f"  {dep}")
    else:
        print("Depends: (none)")
    if show_deps:
        if deps.makedepends:
            print("Make depends:")
            for dep in sorted(deps.makedepends):
                print(f"  {dep}")
        else:
            print("Make depends: (none)")
        if deps.checkdepends:
            print("Check depends:")
            for dep in sorted(deps.checkdepends):
                print(f"  {dep}")
        else:
            print("Check depends: (none)")
        if deps.optdepends:
            print("Optional:")
            for dep in sorted(deps.optdepends):
                print(f"  {dep}")
        else:
            print("Optional: (none)")


def fetch_package(package: str, dest_root: Path, *, refresh: bool, force: bool) -> Path:
    package_dir = ensure_clone(package, dest_root, refresh=refresh, force_reclone=force)
    print(f"Package fetched to {package_dir}")
    return package_dir


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Work with AUR packages via the git mirror or AUR RPC"
    )
    parser.add_argument(
        "--dest-root",
        default="~/.cache/aurgit",
        help="Directory to store cloned packages (default: ~/.cache/aurgit)",
    )
    parser.add_argument("--refresh", action="store_true", help="Refresh existing clones before use")
    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable coloured output",
    )
    parser.add_argument(
        "--aur-rpc",
        dest="aur_rpc",
        action="store_true",
        default=True,
        help="Use the AUR RPC API for metadata and dependency resolution (default)",
    )
    parser.add_argument(
        "--git-mirror",
        dest="aur_rpc",
        action="store_false",
        help="Use the git mirror for metadata and dependency resolution",
    )
    subparsers = parser.add_subparsers(dest="command")

    fetch_parser = subparsers.add_parser("fetch", help="Clone the package branch locally")
    fetch_parser.add_argument("package", help="Package name / branch to clone")
    fetch_parser.add_argument("--force", action="store_true", help="Reclone even if directory exists")

    install_parser = subparsers.add_parser("install", help="Resolve dependencies and build/install a package")
    install_parser.add_argument("package", help="Package name to install")
    install_parser.add_argument("--noconfirm", action="store_true", help="Pass --noconfirm to pacman/makepkg")

    update_parser = subparsers.add_parser(
        "update",
        help="Upgrade installed foreign packages by rebuilding them from the mirror",
    )
    update_parser.add_argument(
        "packages",
        nargs="*",
        help="Specific foreign package names to update (default: all from pacman -Qm)",
    )
    update_parser.add_argument("--noconfirm", action="store_true", help="Pass --noconfirm to pacman/makepkg")
    update_parser.add_argument(
        "--devel",
        action="store_true",
        help="Include VCS/devel packages (e.g. *-git) when checking for updates",
    )
    search_parser = subparsers.add_parser("search", help="Search packages via the configured backend")
    search_parser.add_argument("pattern", help="Substring or regex to match against package names")
    search_parser.add_argument("--regex", action="store_true", help="Treat the pattern as a regular expression")
    search_parser.add_argument("--limit", type=int, help="Limit results to the first N matches")
    search_parser.add_argument(
        "--no-interactive",
        action="store_true",
        help="Disable interactive selection and only list results",
    )
    search_parser.add_argument(
        "--noconfirm",
        action="store_true",
        help="Skip confirmation prompts when installing from search",
    )

    complete_parser = subparsers.add_parser("complete", help=argparse.SUPPRESS)
    complete_parser.add_argument("subcommand", choices=["install"])
    complete_parser.add_argument("prefix", nargs="?", default="")
    complete_parser.add_argument(
        "--limit",
        type=int,
        default=64,
        help="Limit number of completion candidates (default: 64)",
    )

    inspect_parser = subparsers.add_parser("inspect", help="Show PKGBUILD or dependency information")
    inspect_parser.add_argument("package", help="Package name to inspect")
    inspect_parser.add_argument(
        "--target",
        choices=["info", "PKGBUILD", "SRCINFO"],
        default="info",
        help="Which data to show (default: info)",
    )
    inspect_parser.add_argument(
        "--show-build-deps",
        action="store_true",
        help="Include make/check/optional dependencies when showing info",
    )

    return parser


def main(argv: Optional[Sequence[str]] = None) -> int:
    argv_list = list(argv if argv is not None else sys.argv[1:])
    commands = {"fetch", "install", "update", "search", "inspect", "complete"}
    if argv_list and not argv_list[0].startswith("-") and argv_list[0] not in commands:
        reordered: List[str] = []
        remaining: List[str] = []
        i = 0
        while i < len(argv_list):
            item = argv_list[i]
            if item == "--":
                remaining.extend(argv_list[i:])
                break
            if item in _GLOBAL_FLAG_OPTIONS:
                reordered.append(item)
            elif any(item.startswith(f"{opt}=") for opt in _GLOBAL_VALUE_OPTIONS):
                reordered.append(item)
            elif item in _GLOBAL_VALUE_OPTIONS:
                reordered.append(item)
                if i + 1 < len(argv_list):
                    reordered.append(argv_list[i + 1])
                    i += 1
            else:
                remaining.append(item)
            i += 1
        else:
            # ensure natural exit when loop completes without break
            pass
        argv_list = reordered + ["search"] + remaining

    parser = build_parser()
    args = parser.parse_args(argv_list)

    dest_root = Path(os.path.expanduser(args.dest_root)).resolve()
    refresh: bool = bool(args.refresh)
    if args.command is None:
        parser.print_help()
        return 0

    global USE_COLOR, USE_AUR_RPC, FORCE_GIT_MIRROR
    USE_COLOR = not getattr(args, "no_color", False) and sys.stdout.isatty()
    USE_AUR_RPC = bool(getattr(args, "aur_rpc", True))
    FORCE_GIT_MIRROR = not USE_AUR_RPC

    try:
        if args.command == "fetch":
            fetch_package(args.package, dest_root, refresh=refresh, force=args.force)
        elif args.command == "install":
            preinstalled_official: Optional[Set[str]] = None
            if USE_AUR_RPC:
                missing_official, unresolved = collect_missing_official_packages(
                    args.package,
                    dest_root,
                    refresh=refresh,
                )
                if unresolved:
                    missing_list = ", ".join(sorted(unresolved))
                    raise AurGitError(f"Could not resolve providers for: {missing_list}")
                if missing_official:
                    install_official_packages(
                        missing_official,
                        noconfirm=args.noconfirm,
                    )
                preinstalled_official = set(missing_official)
            install_package(
                args.package,
                dest_root,
                refresh=refresh,
                noconfirm=args.noconfirm,
                preinstalled_official=preinstalled_official,
            )
        elif args.command == "update":
            update_packages(
                dest_root,
                refresh=True,
                noconfirm=args.noconfirm,
                include_devel=bool(getattr(args, "devel", False)),
                targets=args.packages or None,
            )
        elif args.command == "search":
            regex_obj: Optional[re.Pattern] = None
            needle: Optional[str] = None
            if args.regex:
                try:
                    regex_obj = re.compile(args.pattern)
                except re.error as exc:
                    print(f"error: invalid regular expression: {exc}", file=sys.stderr)
                    return 1
            else:
                needle = args.pattern.lower()
            results = search_packages(
                args.pattern,
                regex=regex_obj,
                needle=needle,
                limit=args.limit,
            )
            if not results:
                print("No matches found", file=sys.stderr)
                return 1

            ordered_results = order_search_results(results)
            display_results = list(reversed(ordered_results))
            print(style("Search results (best matches last):", CYAN))
            print_search_results(display_results)

            interactive = (
                not args.no_interactive
                and sys.stdin.isatty()
                and sys.stdout.isatty()
            )
            if not interactive:
                return 0

            selected = interactive_select_results(display_results)
            if not selected:
                print(style("No packages selected.", DIM))
                return 0

            print(style("Installing selected packages:", CYAN))
            for item in selected:
                label = style(item.name, BOLD)
                if item.version:
                    label = f"{label} {style(item.version, GREEN)}"
                print(f"  {label}")

            exit_code = 0
            shared_visited: Set[str] = set()
            shared_preinstalled_official: Set[str] = set()
            for item in selected:
                try:
                    install_package(
                        item.name,
                        dest_root,
                        refresh=refresh,
                        noconfirm=args.noconfirm,
                        visited=shared_visited,
                        preinstalled_official=shared_preinstalled_official,
                    )
                except AurGitError as exc:
                    exit_code = 1
                    print(f"error installing {item.name}: {exc}", file=sys.stderr)
            return exit_code
        elif args.command == "complete":
            prefix = args.prefix
            limit = max(1, args.limit)
            names: List[str] = []
            if args.subcommand == "install":
                names = complete_packages(prefix, limit)
            for name in names:
                print(name)
            return 0
        elif args.command == "inspect":
            inspect_package(
                args.package,
                dest_root,
                refresh=refresh,
                target="PKGBUILD" if args.target == "PKGBUILD" else ("SRCINFO" if args.target == "SRCINFO" else "info"),
                show_deps=args.show_build_deps,
            )
        else:
            parser.error("Unknown command")
    except AurGitError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
